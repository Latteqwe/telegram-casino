<!DOCTYPE html>
<html lang="ru">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Rofl Casino ‚Äî Mini App</title>
<link rel="icon" href="images/slot.png" />
<style>
  :root{
    --bg-a:#020b18;
    --bg-b:#06213c;
    --accent: rgba(140,170,223,0.85);
    --text: #cfe8ff;
  }
  html,body{height:100%;margin:0;padding:0;background:linear-gradient(180deg,var(--bg-a),var(--bg-b));font-family: "Montserrat", Arial, sans-serif;color:var(--text);-webkit-font-smoothing:antialiased; -moz-osx-font-smoothing:grayscale;}
  .wrap{box-sizing:border-box;padding:14px;display:flex;flex-direction:column;align-items:center;gap:12px;height:100vh;}
  header{display:flex;align-items:center;gap:12px}
  #logo{height:44px}
  h1{margin:0;font-size:20px;letter-spacing:1px}
  .panel{width:100%;max-width:960px;background:rgba(255,255,255,0.02);border-radius:14px;padding:14px;box-shadow:0 10px 30px rgba(0,0,0,0.6);display:flex;flex-direction:column;gap:12px;box-sizing:border-box}
  .top{display:flex;justify-content:space-between;align-items:center;gap:12px}
  #balance{background:rgba(3,16,28,0.6);padding:8px 14px;border-radius:10px;font-weight:700}
  #message{color:#bcdcff;font-weight:600;min-height:22px;text-align:center}
  /* canvas container */
  #gameArea{position:relative;width:100%;height:56vh;min-height:360px;display:flex;align-items:center;justify-content:center}
  .controls{display:flex;gap:12px;justify-content:center;align-items:center}
  #spinBtn{padding:12px 26px;border-radius:12px;border:none;font-weight:800;cursor:pointer;background:linear-gradient(180deg,#91b7e7,#2b5f91);color:#031028;box-shadow:0 8px 22px rgba(10,30,50,0.6)}
  #spinBtn:active{transform:translateY(1px)}
  @media(max-width:520px){
    #logo{height:36px}
    h1{font-size:16px}
    #gameArea{height:48vh}
  }
</style>
</head>
<body>
  <div class="wrap">
    <header>
      <img id="logo" src="images/slot.png" alt="Rofl" />
      <h1>Rofl Casino</h1>
    </header>

    <div class="panel" style="width:100%">
      <div class="top">
        <div id="balance">–ë–∞–ª–∞–Ω—Å: <span id="balValue">1000</span> üí∞</div>
        <div id="message">–ì–æ—Ç–æ–≤–æ ‚Äî –Ω–∞–∂–º–∏ –ö–†–£–¢–ò!</div>
      </div>

      <div id="gameArea" aria-hidden="false"></div>

      <div class="controls" style="margin-top:6px;">
        <button id="spinBtn">–ö–†–£–¢–ò!</button>
      </div>
    </div>
  </div>

  <!-- sounds -->
  <audio id="clickSound" src="sounds/click.mp3" preload="auto"></audio>
  <audio id="winSound" src="sounds/win.mp3" preload="auto"></audio>
  <audio id="loseSound" src="sounds/lose.mp3" preload="auto"></audio>
  <audio id="jackpotSound" src="sounds/jackpot.mp3" preload="auto"></audio>

  <!-- PIXI -->
  <script src="https://pixijs.download/release/pixi.min.js"></script>

  <script>
  (function(){
    // ------------- CONFIG -------------
    const START_BALANCE = 1000;
    const STAKE = 100;
    const REEL_COUNT = 3;
    const SYMBOLS = [
      {name:'banana', file:'images/banana.png'},
      {name:'star',   file:'images/star.png'},
      {name:'gem',    file:'images/gem.png'},
      {name:'cherry', file:'images/cherry.png'},
      {name:'bell',   file:'images/bell.png'},
      {name:'lemon',  file:'images/lemon.png'}
    ];
    const VISIBLE_SPRITES = 7; // odd number
    const CENTER_INDEX = Math.floor(VISIBLE_SPRITES/2);
    const TOTAL_DURATION = 9000; // ms total sequence (approx)
    const PER_REEL = TOTAL_DURATION / REEL_COUNT; // ms per reel active
    const BASE_TICK = 80; // ms per visual tick during spin
    // depth tuning
    const MAX_SCALE_DIFF = 0.36;
    const MAX_ALPHA_DIFF = 0.55;
    const MAX_BLUR_PX = 6;
    // particle tuning
    const PARTICLE_BASE = 3;
    const PARTICLE_FADE = 900;

    // audio elements from DOM
    const clickAudio = document.getElementById('clickSound');
    const winAudio = document.getElementById('winSound');
    const loseAudio = document.getElementById('loseSound');
    const jackpotAudio = document.getElementById('jackpotSound');
    try { clickAudio.volume = 0.28; winAudio.volume = 0.55; loseAudio.volume = 0.4; jackpotAudio.volume = 0.75; }catch(e){}

    // DOM
    const gameArea = document.getElementById('gameArea');
    const spinBtn = document.getElementById('spinBtn');
    const balValEl = document.getElementById('balValue');
    const messageEl = document.getElementById('message');

    let balance = START_BALANCE;
    balValEl.textContent = balance;

    // PIXI app
    const app = new PIXI.Application({
      resizeTo: gameArea,
      backgroundAlpha: 0,
      antialias: true,
      resolution: devicePixelRatio || 1
    });
    gameArea.appendChild(app.view);

    // preload assets via loader and keep a map
    const loader = new PIXI.Loader();
    SYMBOLS.forEach(s => loader.add(s.name, s.file));
    loader.add('slot', 'images/slot.png');

    // small particle texture (circle) to reuse
    function createParticleTexture(){
      const g = new PIXI.Graphics();
      g.beginFill(0xAAD0FF);
      g.drawCircle(0,0,6);
      g.endFill();
      return app.renderer.generateTexture(g, PIXI.SCALE_MODES.LINEAR, devicePixelRatio || 1);
    }

    loader.load((loader, resources) => {
      // resources now loaded
      const textures = SYMBOLS.map(s => resources[s.name].texture);

      // containers
      const reelsContainer = new PIXI.Container();
      app.stage.addChild(reelsContainer);

      const particlesContainer = new PIXI.Container();
      app.stage.addChild(particlesContainer);

      // create particle texture once
      const particleTex = createParticleTexture();

      // build reels data
      const reels = [];
      function buildReels(){
        reelsContainer.removeChildren();
        reels.length = 0;
        const w = app.renderer.width;
        const h = app.renderer.height;
        const reelSize = Math.min(180, Math.max(64, Math.floor(w / (REEL_COUNT + 1.5))));
        const step = reelSize * 0.88;
        const spacing = reelSize + Math.floor(reelSize*0.08);
        const startX = (w - ((REEL_COUNT-1)*spacing + reelSize))/2 + reelSize/2;
        const centerY = h/2;

        for (let r=0;r<REEL_COUNT;r++){
          const c = new PIXI.Container();
          c.x = startX + r * spacing;
          c.y = centerY;
          c.reelSize = reelSize;
          reelsContainer.addChild(c);

          // create sprites vertically
          const sprites = [];
          const startOffset = -CENTER_INDEX * step;
          for (let i=0;i<VISIBLE_SPRITES;i++){
            const tex = textures[Math.floor(Math.random()*textures.length)];
            const sp = new PIXI.Sprite(tex);
            sp.anchor.set(0.5);
            sp.x = 0;
            sp.y = startOffset + i * step;
            sp.scale.set(1);
            // store filename for identification
            sp._fname = tex.baseTexture.resource.url.split('/').pop();
            // each sprite will have a BlurFilter object to modify later
            sp._blur = new PIXI.filters.BlurFilter(0);
            sp.filters = [sp._blur];
            c.addChild(sp);
            sprites.push(sp);
          }
          reels.push({
            container: c,
            sprites,
            step,
            spinning: false
          });
        }
        updateDepth(); // initial visual tune
      }

      buildReels();

      // handle resizing => rebuild so positions consistent
      const ro = new ResizeObserver(()=> {
        app.renderer.resize(gameArea.clientWidth, gameArea.clientHeight);
        buildReels();
      });
      ro.observe(gameArea);

      // helper: play safe audio
      function playSafe(a){ try{ a.currentTime=0; a.play().catch(()=>{}); }catch(e){} }

      // Particles array of sprites
      const particlePool = []; // reuse sprites
      const activeParticles = [];

      function spawnParticle(x,y,intensity=1){
        const spt = particlePool.length ? particlePool.pop() : new PIXI.Sprite(particleTex);
        spt.anchor.set(0.5);
        spt.x = x;
        spt.y = y;
        const angle = (Math.random()-0.5)*Math.PI; // mostly up
        const speed = (0.6+Math.random()*1.6) * (0.9+intensity);
        spt.vx = Math.cos(angle)*speed;
        spt.vy = Math.sin(angle)*speed - 0.8*intensity;
        spt.life = PARTICLE_FADE * (0.7 + Math.random()*0.8);
        spt.born = performance.now();
        spt.scale.set((0.5 + Math.random()*1.2) * (0.6 + intensity*0.4));
        spt.alpha = 0.45 * (0.6 + Math.random()*0.6); // softer
        spt.tint = 0xAACFEF;
        particlesContainer.addChild(spt);
        activeParticles.push(spt);
      }

      function updateParticles(now, dt){
        for (let i = activeParticles.length-1; i>=0; i--){
          const p = activeParticles[i];
          const age = now - p.born;
          if (age > p.life){
            particlesContainer.removeChild(p);
            activeParticles.splice(i,1);
            particlePool.push(p);
            continue;
          }
          const t = 1 - age / p.life;
          p.x += p.vx * (dt/16);
          p.y += p.vy * (dt/16);
          p.vx *= 0.995;
          p.vy += 0.02;
          p.alpha = (t * 0.45) * (0.5 + Math.random()*0.5); // gentle fade + small flicker
          p.scale.set(p.scale.x * (0.995)); // slight shrink
        }
      }

      // depth visuals: scale/alpha/blur by distance to center (s.y)
      function updateDepth(){
        for (const reel of reels){
          const step = reel.step;
          for (const s of reel.sprites){
            const dist = Math.abs(s.y) / (step * CENTER_INDEX);
            const norm = Math.min(1, dist);
            const scale = 1 - MAX_SCALE_DIFF * norm;
            s.scale.set(scale);
            s.alpha = 1 - MAX_ALPHA_DIFF * norm;
            s._blur.blur = MAX_BLUR_PX * norm;
            // slight darkness at edges (via tint multiplier)
            const brightness = 0.75 + 0.25 * (1 - norm);
            const c = Math.floor(255 * brightness);
            s.tint = (c<<16) | (c<<8) | c;
          }
        }
      }

      // spin logic: sequential reels
      let spinning = false;

      function randomSymbolTexture(){
        const idx = Math.floor(Math.random()*SYMBOLS.length);
        return {
          texture: PIXI.Texture.from(SYMBOLS[idx].file),
          name: SYMBOLS[idx].name
        };
      }

      // utility to emit particles from reel center
      function emitFromReel(r, intensity=1){
        const container = reels[r].container;
        const global = container.toGlobal(new PIXI.Point(0,0));
        const baseX = global.x;
        const baseY = global.y;
        const count = Math.max(1, Math.round(PARTICLE_BASE * (1 + intensity*2)));
        for (let i=0;i<count;i++) spawnParticle(baseX + (Math.random()-0.5)*30, baseY + (Math.random()-0.5)*20, intensity);
      }

      // core: spin a single reel for duration ms and then land on targetFile
      async function spinReel(r, duration, targetFile){
        const reel = reels[r];
        reel.spinning = true;
        const step = reel.step;
        const start = performance.now();
        let last = start;
        // spinning: move sprites upward continuously
        while (performance.now() - start < duration){
          const now = performance.now();
          const dt = now - last;
          last = now;
          const speed = 0.9 + ( (duration - (now - start)) / duration ) * 0.6; // small variation
          const move = speed * (step/6) * (dt/16);
          for (let s of reel.sprites) s.y -= move;
          // wrap
          const threshold = -step * (CENTER_INDEX + 0.6);
          for (let i=0;i<reel.sprites.length;i++){
            const s = reel.sprites[i];
            if (s.y < threshold){
              s.y += step * reel.sprites.length;
              const rnd = randomSymbolTexture();
              s.texture = rnd.texture;
              s._fname = rnd.name;
            }
          }
          // particles and depth update
          emitFromReel(r, 0.6);
          updateDepth();
          // wait small tick to avoid locking
          await new Promise(res => setTimeout(res, BASE_TICK));
        }

        // now approach landing: perform N small steps to align center with target
        const steps = 10 + Math.floor(Math.random()*6);
        for (let st=0; st<steps; st++){
          const now = performance.now();
          // shift a fraction of step smoothly
          const frac = 1 / (steps - st + 1);
          const move = step * frac * (0.9 + Math.random()*0.2);
          for (let s of reel.sprites) s.y -= move;
          // wrap
          const threshold = -step * (CENTER_INDEX + 0.6);
          for (let i=0;i<reel.sprites.length;i++){
            const s = reel.sprites[i];
            if (s.y < threshold){
              s.y += step * reel.sprites.length;
              const rnd = randomSymbolTexture();
              s.texture = rnd.texture;
              s._fname = rnd.name;
            }
          }
          // small particle bursts
          for (let p=0;p<2;p++) emitFromReel(r, 0.6);
          updateDepth();
          await new Promise(res => setTimeout(res, 60 + st*18));
        }

        // set center sprite to targetFile
        let centerSprite = null;
        let minD = Infinity;
        for (const s of reel.sprites){
          if (Math.abs(s.y) < minD){ minD = Math.abs(s.y); centerSprite = s; }
        }
        if (centerSprite){
          centerSprite.texture = PIXI.Texture.from(targetFile);
          centerSprite._fname = targetFile.split('/').pop().replace('.png','');
          // align exactly by shifting all sprites so that centerSprite.y becomes 0
          const offset = centerSprite.y;
          const alignFrames = 10;
          for (let f=0; f<alignFrames; f++){
            const t = (f+1)/alignFrames;
            for (let s of reel.sprites) s.y -= offset * (t/alignFrames) / alignFrames;
            updateDepth();
            await new Promise(res => setTimeout(res, 14));
          }
        }

        // micro bounce
        const bounceFrames = 8;
        for (let b=0;b<bounceFrames;b++){
          const amp = Math.sin((b/bounceFrames)*Math.PI) * 6 * (1 - b/bounceFrames);
          for (let s of reel.sprites) s.y -= amp;
          updateDepth();
          await new Promise(res => setTimeout(res, 14));
        }

        // small final particles
        for (let i=0;i<6;i++) emitFromReel(r, 0.9*Math.random());

        reel.spinning = false;
      }

      // generate final result
      function generateResult(){
        const rnd = Math.random()*100;
        if (rnd <= 1){
          const f = SYMBOLS[Math.floor(Math.random()*SYMBOLS.length)].file;
          return [f,f,f];
        } else if (rnd <= 21){
          const s1 = SYMBOLS[Math.floor(Math.random()*SYMBOLS.length)].file;
          let s2;
          do { s2 = SYMBOLS[Math.floor(Math.random()*SYMBOLS.length)].file } while (s2 === s1);
          return Math.random()<0.5 ? [s1,s1,s2] : [s1,s2,s1];
        } else {
          const picked = [];
          while (picked.length < 3){
            const p = SYMBOLS[Math.floor(Math.random()*SYMBOLS.length)].file;
            if (!picked.includes(p)) picked.push(p);
          }
          return picked;
        }
      }

      // main spinAll (sequential start)
      async function spinAll(){
        if (spinning) return;
        spinning = true;
        spinBtn.disabled = true;
        messageEl.textContent = '';
        balance -= STAKE;
        balValEl.textContent = balance;

        // let bot know we started (Telegram WebApp)
        if (window.Telegram && Telegram.WebApp) Telegram.WebApp.sendData(JSON.stringify({action:'start_game'}));

        const finals = generateResult();
        // start each reel with little offset for visual stagger
        const startOffsets = [0, 220, 420];
        const reelPromises = [];
        for (let r=0;r<REEL_COUNT;r++){
          const p = new Promise(res => setTimeout(()=> {
            spinReel(r, PER_REEL, finals[r]).then(()=>res());
          }, startOffsets[r]));
          reelPromises.push(p);
        }
        // while spinning, animate particles update via ticker
        // wait all reels done
        await Promise.all(reelPromises);

        // evaluate results based on center sprite filenames
        const names = reels.map(re => {
          const sp = re.sprites[CENTER_INDEX];
          const src = sp.texture.baseTexture.resource.url || '';
          return src.split('/').pop().replace('.png','');
        });

        const allEqual = (names[0] === names[1] && names[1] === names[2]);
        const anyPair = (names[0] === names[1] || names[1] === names[2] || names[0] === names[2]);
        let change = 0;
        let msg = '';
        if (allEqual){
          if (names[0].includes('gem')){ change = 1000; msg = 'üéâ JACKPOT!'; playSafe(jackpotAudio); }
          else { change = 800; msg = 'üî• –ë–æ–ª—å—à–æ–π –≤—ã–∏–≥—Ä—ã—à!'; playSafe(winAudio); }
        } else if (anyPair){ change = 200; msg = 'üòâ –ü–æ—á—Ç–∏ ‚Äî –º–µ–ª–∫–∏–π –≤—ã–∏–≥—Ä—ã—à'; playSafe(winAudio); }
        else { change = 0; msg = 'üôÅ –£–≤—ã ‚Äî –ø–æ–ø—Ä–æ–±—É–π –µ—â—ë'; playSafe(loseAudio); }

        if (change > 0){
          flashBG();
          pulseWinners(names);
        }

        balance += change;
        balValEl.textContent = balance;
        messageEl.textContent = msg;

        // notify bot
        if (window.Telegram && Telegram.WebApp){
          Telegram.WebApp.sendData(JSON.stringify({action:'slot_result', result: names.join(','), change: change}));
        }

        spinning = false;
        spinBtn.disabled = false;
      }

      // small UI effects
      function flashBG(){
        const orig = document.body.style.background;
        document.body.style.transition = 'background 700ms ease';
        document.body.style.background = 'linear-gradient(180deg,#072b4a,#06314a)';
        setTimeout(()=> { document.body.style.background = orig; }, 1000);
      }
      function pulseWinners(names){
        // pulse center sprite for winners
        for (let r=0;r<REEL_COUNT;r++){
          const sp = reels[r].sprites[CENTER_INDEX];
          const baseScale = sp.scale.x;
          let t0 = performance.now();
          const dur = 900;
          function tick(){
            const t = (performance.now() - t0)/dur;
            if (t >= 1){ sp.scale.set(baseScale); return; }
            const ease = Math.sin(Math.PI * t);
            sp.scale.set(baseScale * (1 + 0.18 * ease));
            requestAnimationFrame(tick);
          }
          // mark pair/triple only
          if (names.filter(n=>n===names[r]).length > 1) tick();
        }
      }

      // Play safe wrapper for audio
      function playSafe(a){ try{ a.currentTime = 0; a.play().catch(()=>{});}catch(e){} }

      // update loop for particles (driven by ticker)
      let last = performance.now();
      app.ticker.add(()=> {
        const now = performance.now();
        const dt = now - last;
        last = now;
        updateParticles(now, dt);
      });

      // attach button
      spinBtn.addEventListener('click', ()=> { spinAll().catch(e=>{ console.error(e); spinning=false; spinBtn.disabled=false;}); });

      // expose for debug
      window._reels = reels;

      // initial render update
      updateDepth();

      console.log('Rofl Casino ready ‚Äî assets loaded.');
    }); // end loader.load

  })();
  </script>
</body>
</html>
