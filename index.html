<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Слоты</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background-color: #111;
            overflow: hidden;
        }
        canvas {
            display: block;
        }
    </style>
</head>
<body>
<script src="https://cdnjs.cloudflare.com/ajax/libs/pixi.js/8.1.5/pixi.min.js"></script>
<script>
(async () => {
    const app = new PIXI.Application();
    await app.init({ 
        background: '#111', 
        resizeTo: window 
    });
    document.body.appendChild(app.canvas);

    const symbols = [
        'images/banana.png',
        'images/star.png',
        'images/gem.png',
        'images/cherry.png',
        'images/bell.png',
        'images/lemon.png'
    ];

    const assets = {};
    for (let path of symbols) {
        assets[path] = await PIXI.Assets.load(path);
    }
    const slotIcon = await PIXI.Assets.load('images/slot.png');

    const reelWidth = 160;
    const symbolSize = 150;
    const reels = [];
    const reelContainer = new PIXI.Container();
    app.stage.addChild(reelContainer);

    const reelCount = 3;
    for (let i = 0; i < reelCount; i++) {
        const rc = new PIXI.Container();
        rc.x = i * reelWidth;
        reelContainer.addChild(rc);

        const reel = {
            container: rc,
            symbols: [],
            position: 0,
            previousPosition: 0,
            blur: new PIXI.BlurFilter()
        };
        rc.filters = [reel.blur];

        for (let j = 0; j < 4; j++) {
            const texture = assets[symbols[Math.floor(Math.random() * symbols.length)]];
            const symbol = new PIXI.Sprite(texture);
            symbol.y = j * symbolSize;
            symbol.x = Math.round((reelWidth - symbol.width) / 2);
            reel.symbols.push(symbol);
            rc.addChild(symbol);
        }
        reels.push(reel);
    }
    reelContainer.x = (app.screen.width - reelWidth * reelCount) / 2;
    reelContainer.y = (app.screen.height - symbolSize * 3) / 2;

    function startPlay() {
        let running = 0;
        for (let i = 0; i < reels.length; i++) {
            const r = reels[i];
            const extra = Math.floor(Math.random() * 3);
            const target = r.position + 10 + i * 5 + extra;
            const time = 2500 + i * 600;

            tweenTo(r, 'position', target, time, backout(0.5), null, i === reels.length - 1 ? reelsComplete : null);
        }
    }

    function reelsComplete() {
        console.log('Spin complete');
    }

    function backout(amount) {
        return t => (--t * t * ((amount + 1) * t + amount) + 1);
    }

    const tweening = [];
    function tweenTo(object, property, target, time, easing, onchange, oncomplete) {
        const tween = { object, property, propertyBeginValue: object[property], target, easing, time, change: onchange, complete: oncomplete, start: Date.now() };
        tweening.push(tween);
        return tween;
    }

    app.ticker.add(() => {
        const now = Date.now();
        const remove = [];
        for (let i = 0; i < tweening.length; i++) {
            const t = tweening[i];
            const phase = Math.min(1, (now - t.start) / t.time);
            t.object[t.property] = lerp(t.propertyBeginValue, t.target, t.easing(phase));
            if (t.change) t.change(t);
            if (phase === 1) {
                t.object[t.property] = t.target;
                if (t.complete) t.complete(t);
                remove.push(t);
            }
        }
        for (let rem of remove) {
            tweening.splice(tweening.indexOf(rem), 1);
        }

        for (let i = 0; i < reels.length; i++) {
            const r = reels[i];
            r.blur.blurY = (r.position - r.previousPosition) * 8;
            r.previousPosition = r.position;

            for (let j = 0; j < r.symbols.length; j++) {
                const s = r.symbols[j];
                const prevY = s.y;
                s.y = ((r.position + j) % r.symbols.length) * symbolSize - symbolSize;

                let middle = app.screen.height / 2;
                let dist = Math.abs(s.y + reelContainer.y - middle);
                let scale = 1 - dist / 600;
                s.scale.set(Math.max(0.5, scale));

                s.alpha = Math.max(0.5, scale);
                s.tint = scale < 0.8 ? 0x888888 : 0xFFFFFF;

                if (s.y < -symbolSize) {
                    const texture = assets[symbols[Math.floor(Math.random() * symbols.length)]];
                    s.texture = texture;
                    s.y += symbolSize * r.symbols.length;
                }
            }
        }
    });

    function lerp(a1, a2, t) {
        return a1 * (1 - t) + a2 * t;
    }

    window.addEventListener('pointerdown', startPlay);
})();
</script>
</body>
</html>
