<!DOCTYPE html>
<html lang="ru">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Rofl Casino ‚Äî Mini App</title>
<link rel="icon" href="images/slot.png" />
<style>
  :root{
    --bg-a:#020b18;
    --bg-b:#06213c;
    --accent: rgba(140,170,223,0.85);
    --text: #cfe8ff;
  }
  html,body{height:100%;margin:0;padding:0;background:linear-gradient(180deg,var(--bg-a),var(--bg-b));font-family: "Montserrat", Arial, sans-serif;color:var(--text);-webkit-font-smoothing:antialiased; -moz-osx-font-smoothing:grayscale;}
  .wrap{box-sizing:border-box;padding:14px;display:flex;flex-direction:column;align-items:center;gap:12px;height:100vh;}
  header{display:flex;align-items:center;gap:12px}
  #logo{height:44px}
  h1{margin:0;font-size:20px;letter-spacing:1px}
  .panel{width:100%;max-width:960px;background:rgba(255,255,255,0.02);border-radius:14px;padding:14px;box-shadow:0 10px 30px rgba(0,0,0,0.6);display:flex;flex-direction:column;gap:12px;box-sizing:border-box}
  .top{display:flex;justify-content:space-between;align-items:center;gap:12px}
  #balance{background:rgba(3,16,28,0.6);padding:8px 14px;border-radius:10px;font-weight:700}
  #message{color:#bcdcff;font-weight:600;min-height:22px;text-align:center}
  /* canvas container */
  #gameArea{position:relative;width:100%;height:48vh;min-height:320px;display:flex;align-items:center;justify-content:center}
  /* fallback (visible for non-canvas) */
  .controls{display:flex;gap:12px;justify-content:center;align-items:center}
  #spinBtn{padding:12px 26px;border-radius:12px;border:none;font-weight:800;cursor:pointer;background:linear-gradient(180deg,#91b7e7,#2b5f91);color:#031028;box-shadow:0 8px 22px rgba(10,30,50,0.6)}
  #spinBtn:active{transform:translateY(1px)}
  @media(max-width:520px){
    #logo{height:36px}
    h1{font-size:16px}
    #gameArea{height:44vh}
  }
</style>
</head>
<body>
  <div class="wrap">
    <header>
      <img id="logo" src="images/slot.png" alt="Rofl" />
      <h1>Rofl Casino</h1>
    </header>

    <div class="panel" style="width:100%">
      <div class="top">
        <div id="balance">–ë–∞–ª–∞–Ω—Å: <span id="balValue">1000</span> üí∞</div>
        <div id="message">–ì–æ—Ç–æ–≤–æ ‚Äî –Ω–∞–∂–º–∏ –ö–†–£–¢–ò!</div>
      </div>

      <div id="gameArea" aria-hidden="false"></div>

      <div class="controls">
        <button id="spinBtn">–ö–†–£–¢–ò!</button>
      </div>
    </div>
  </div>

  <!-- sounds from sounds/ (user said they are present) -->
  <audio id="clickSound" src="sounds/click.mp3" preload="auto"></audio>
  <audio id="winSound" src="sounds/win.mp3" preload="auto"></audio>
  <audio id="loseSound" src="sounds/lose.mp3" preload="auto"></audio>
  <audio id="jackpotSound" src="sounds/jackpot.mp3" preload="auto"></audio>

  <!-- PIXI -->
  <script src="https://pixijs.download/release/pixi.min.js"></script>

  <script>
  /* -----------------------------
     Rofl Casino ‚Äî PixiJS index.html
     Features:
     - uses images from images/
     - uses sounds from sounds/
     - 3D illusion: scale/alpha/blur by distance to center
     - motion blur during fast spin
     - particles (soft, fade-out, no clipping)
     - sequential reel stops, total ~9s
     - micro-bounce on stop
     ------------------------------ */

  (async function(){
    // ---------- CONFIG ----------
    const REEL_COUNT = 3;
    const SYMBOL_FILES = [
      'images/banana.png',
      'images/star.png',
      'images/gem.png',
      'images/cherry.png',
      'images/bell.png',
      'images/lemon.png'
    ];
    const START_BALANCE = 1000;
    const STAKE = 100;
    const TOTAL_DURATION = 9000; // ms total sequence
    const PER_REEL = TOTAL_DURATION / REEL_COUNT; // 3000
    const TICK_MS = 80; // symbol swap interval while spinning
    // visual tuning
    const VISIBLE_SPRITES = 7; // sprites per reel vertically (odd number preferred)
    const CENTER_INDEX = Math.floor(VISIBLE_SPRITES/2);
    // depth effect tuning
    const MAX_SCALE_DIFF = 0.36; // how much smaller far items are
    const MAX_ALPHA_DIFF = 0.5;  // how much more transparent at edges
    const MAX_BLUR = 6; // px blur at furthest
    const MOTION_BLUR_MULT = 0.08; // multiplier to convert speed -> blur

    // particles tuning
    const PARTICLE_RATE = 4; // base particles per tick
    const PARTICLE_FADE = 900; // ms

    // audio elements
    const clickAudio = document.getElementById('clickSound');
    const winAudio = document.getElementById('winSound');
    const loseAudio = document.getElementById('loseSound');
    const jackpotAudio = document.getElementById('jackpotSound');
    try { clickAudio.volume = 0.28; winAudio.volume = 0.55; loseAudio.volume = 0.4; jackpotAudio.volume = 0.75; } catch(e){}

    // DOM refs
    const gameArea = document.getElementById('gameArea');
    const spinBtn = document.getElementById('spinBtn');
    const balEl = document.getElementById('balValue');
    const messageEl = document.getElementById('message');

    let balance = START_BALANCE;
    balEl.textContent = balance;

    // Pixi app (resize to container)
    const app = new PIXI.Application({
      resizeTo: gameArea,
      backgroundAlpha: 0,
      antialias: true,
      resolution: devicePixelRatio || 1
    });
    gameArea.appendChild(app.view);

    // stage layout parameters
    function layout(){
      // container width inside app.renderer
      const w = app.renderer.width;
      const h = app.renderer.height;
      // compute reel spacing
      const reelWidth = Math.min(180, Math.max(64, Math.floor(w / (REEL_COUNT + 1.5))));
      return {w,h,reelWidth};
    }

    // preloader textures
    const loader = new PIXI.Loader();
    SYMBOL_FILES.forEach(f => loader.add(f));
    loader.add('slotLogo', 'images/slot.png');
    await new Promise((res, rej) => loader.load((l, r) => res()));

    // create containers for reels
    const reelsContainer = new PIXI.Container();
    app.stage.addChild(reelsContainer);

    // particle container on top
    const particlesContainer = new PIXI.Container();
    app.stage.addChild(particlesContainer);

    // filters
    const globalBlurFilter = new PIXI.filters.BlurFilter(0);
    app.stage.filters = []; // we'll use per-sprite blur for depth illusion

    // data structures
    const reels = [];

    // helper to create a sprite for a symbol
    function createSymbolSprite(texture){
      const sprite = new PIXI.Sprite(texture);
      sprite.anchor.set(0.5);
      sprite.scale.set(1);
      sprite.texture.baseTexture.scaleMode = PIXI.SCALE_MODES.LINEAR;
      // allow per-sprite filters
      sprite.filters = [];
      return sprite;
    }

    // Build reels
    function buildReels(){
      reelsContainer.removeChildren();
      reels.length = 0;
      const {w,h,reelWidth} = layout();
      const spacing = reelWidth + Math.floor(reelWidth*0.1);
      const startX = (w - ((REEL_COUNT-1)*spacing + reelWidth))/2;
      const centerY = h/2;

      for(let r=0;r<REEL_COUNT;r++){
        const reelC = new PIXI.Container();
        reelC.x = startX + r * spacing + reelWidth/2;
        reelC.y = centerY;
        reelC.reelWidth = reelWidth;
        reelC.centerY = centerY;
        reelsContainer.addChild(reelC);

        // create a vertical stack of visible sprites (VISIBLE_SPRITES)
        const textureList = SYMBOL_FILES.map(f => PIXI.Texture.from(f));
        const sprites = [];
        const slotH = reelWidth; // roughly square
        const step = slotH * 0.85; // spacing between sprites
        const startOffset = -CENTER_INDEX * step;

        for (let i = 0; i < VISIBLE_SPRITES; i++){
          const tex = textureList[Math.floor(Math.random()*textureList.length)];
          const s = createSymbolSprite(tex);
          s.x = 0;
          s.y = startOffset + i * step;
          reelC.addChild(s);
          sprites.push(s);
        }

        reels.push({
          container: reelC,
          sprites,
          speed: 0, // px/ms
          spinning: false,
          ticker: null
        });
      }
    }

    buildReels();
    app.renderer.resize(app.view.width, app.view.height);

    // adjust visuals per frame: scale/alpha/blur depending on sprite.y distance to center
    function updateDepthVisuals(){
      for (let r=0;r<reels.length;r++){
        const reel = reels[r];
        const step = (reel.sprites[1].y - reel.sprites[0].y) || 1;
        for (let s of reel.sprites){
          // normalized distance: 0 center, 1 at farthest shown
          const dist = Math.abs(s.y) / (Math.abs(step)*CENTER_INDEX);
          const norm = Math.min(1, dist);
          // scale interpolates from 1 (center) down to (1 - MAX_SCALE_DIFF)
          const scale = 1 - MAX_SCALE_DIFF * norm;
          s.scale.set(scale);
          // alpha slightly lower at edges
          s.alpha = 1 - MAX_ALPHA_DIFF * norm;
          // subtle tint darkening at edges: use tint by multiplying (simple)
          const tintVal = Math.floor(0xFFFFFF * (0.7 + 0.3*(1 - norm))); // center brighter
          s.tint = 0xFFFFFF; // keep color, rely on alpha and blur for depth
          // blur: create or reuse blur filter per sprite
          const blurAmount = MAX_BLUR * norm;
          if (!s._blurFilter){
            s._blurFilter = new PIXI.filters.BlurFilter(blurAmount);
            s.filters = [s._blurFilter];
          } else {
            s._blurFilter.blur = blurAmount;
          }
          // slight vertical skew or brightness could be added, but keep performance
        }
      }
    }

    // call on resize too
    window.addEventListener('resize', () => {
      // rebuild layout when size changes to adjust spacing
      const {w,h,reelWidth} = layout();
      // reposition reels
      const spacing = reelWidth + Math.floor(reelWidth*0.1);
      const startX = (w - ((REEL_COUNT-1)*spacing + reelWidth))/2;
      const centerY = h/2;
      for (let r=0;r<reels.length;r++){
        const reel = reels[r];
        reel.container.x = startX + r * spacing + reelWidth/2;
        reel.container.y = centerY;
        // reposition sprites step
        const step = reelWidth * 0.85;
        const startOffset = -CENTER_INDEX * step;
        for (let i=0;i<reel.sprites.length;i++){
          reel.sprites[i].y = startOffset + i*step;
        }
      }
      updateDepthVisuals();
    });

    // Utility: play safe
    function playSafe(audio){
      try{ audio.currentTime = 0; audio.play().catch(()=>{}); } catch(e){}
    }

    // Particle system (soft particles, fade out)
    const particles = [];
    function spawnParticle(x,y, vx,vy, life, size, col){
      particles.push({x,y,vx,vy,life,born:performance.now(),size,col});
    }
    function updateParticles(now, dt){
      const ctx = particlesContainer;
      // Clear container children and redraw (using Graphics per particle could be heavy; use simple sprites via PIXI.Graphics cached textures)
      particlesContainer.removeChildren();
      for (let i = particles.length-1; i >=0; i--){
        const p = particles[i];
        const age = now - p.born;
        if (age > p.life){ particles.splice(i,1); continue; }
        const t = 1 - age / p.life;
        // draw as small sprite via Graphics
        const g = new PIXI.Graphics();
        const alpha = t * 0.6; // more transparent
        const size = p.size * (0.6 + 0.4*(1-t));
        g.beginFill(p.col, alpha);
        g.drawCircle(0,0,size);
        g.endFill();
        g.x = p.x;
        g.y = p.y;
        // slight glow using blur filter on graphics; cheap alternative: use alpha
        g.alpha = alpha;
        particlesContainer.addChild(g);
        // integrate
        p.vx *= 0.995;
        p.vy += 0.02;
        p.x += p.vx * dt;
        p.y += p.vy * dt;
      }
    }

    // function to emit particles from reel center
    function emitParticlesFromReel(reelIndex, intensity=1){
      const rc = reels[reelIndex];
      const globalPos = rc.container.toGlobal(new PIXI.Point(0,0)); // center
      const baseX = globalPos.x;
      const baseY = globalPos.y;
      const count = Math.round(PARTICLE_RATE * (1 + intensity*2));
      for (let i=0;i<count;i++){
        const angle = (Math.random()-0.5)*Math.PI; // mostly upward and sideways
        const speed = (0.8 + Math.random()*1.8) * (0.8 + intensity*0.9);
        const vx = Math.cos(angle) * speed * (Math.random()*1.2);
        const vy = Math.sin(angle) * speed * (Math.random()*0.8) - 0.6*intensity;
        const life = PARTICLE_FADE * (0.6 + Math.random()*0.9);
        const size = 2 + Math.random()*5;
        spawnParticle(baseX + (Math.random()-0.5)*30, baseY + (Math.random()-0.5)*30, vx, vy, life, size, 0xaad0ff);
      }
    }

    // Spin controller: sequential spinning with deceleration to land on target symbols
    let isSpinning = false;

    function generateFinalSymbols(){
      // same RNG logic as earlier: 1% triple, 20% pair, else distinct
      const rand = Math.random()*100;
      if (rand <= 1){
        const s = SYMBOL_FILES[Math.floor(Math.random()*SYMBOL_FILES.length)];
        return [s,s,s];
      } else if (rand <= 21){
        const s1 = SYMBOL_FILES[Math.floor(Math.random()*SYMBOL_FILES.length)];
        let s2;
        do { s2 = SYMBOL_FILES[Math.floor(Math.random()*SYMBOL_FILES.length)]; } while (s2 === s1);
        if (Math.random() < 0.5) return [s1,s1,s2];
        return [s1,s2,s1];
      } else {
        const chosen = [];
        while (chosen.length < 3){
          const s = SYMBOL_FILES[Math.floor(Math.random()*SYMBOL_FILES.length)];
          if (!chosen.includes(s)) chosen.push(s);
        }
        return chosen;
      }
    }

    // core spin routine (async)
    async function spinAll(){
      if (isSpinning) return;
      isSpinning = true;
      spinBtn.disabled = true;
      messageEl.textContent = '';
      balance -= STAKE;
      balEl.textContent = balance;

      const finals = generateFinalSymbols();

      // inform bot start
      if (window.Telegram && Telegram.WebApp) Telegram.WebApp.sendData(JSON.stringify({action:'start_game'}));

      // for temporal control, each reel runs for PER_REEL ms, sequential start (we'll start reel0 immediately, reel1 after 200ms, reel2 after 400ms for nicer stagger)
      const startDelays = [0, 200, 400];
      const reelPromises = [];

      for (let r = 0; r < REEL_COUNT; r++){
        const promise = new Promise(resolve => {
          setTimeout(()=> {
            spinSingleReel(r, finals[r], resolve);
          }, startDelays[r]);
        });
        reelPromises.push(promise);
      }

      // await all reels
      await Promise.all(reelPromises);

      // compute results
      const landed = reels.map(re => re.sprites[CENTER_INDEX].texture.textureCacheIds?.[0] || re.sprites[CENTER_INDEX].texture.baseTexture.resource.url || '');
      // to get names, compare file end
      const names = landed.map(src => {
        const fname = src.split('/').pop();
        const sym = SYMBOL_FILES.find(s => s.split('/').pop() === fname);
        return sym ? sym.replace(/^images\//,'').replace('.png','') : fname;
      });

      // count wins
      const allEqual = (names[0] === names[1] && names[1] === names[2]);
      const anyPair = (names[0] === names[1] || names[1] === names[2] || names[0] === names[2]);
      let change = 0;
      let resultMsg = '';

      if (allEqual){
        if (names[0].includes('gem')){
          change = 1000; resultMsg = 'üéâ JACKPOT!';
          playSafe(jackpotAudio);
        } else {
          change = 800; resultMsg = 'üî• –ë–æ–ª—å—à–æ–π –≤—ã–∏–≥—Ä—ã—à!';
          playSafe(winAudio);
        }
      } else if (anyPair){
        change = 200; resultMsg = 'üòâ –ü–æ—á—Ç–∏ ‚Äî –º–µ–ª–∫–∏–π –≤—ã–∏–≥—Ä—ã—à';
        playSafe(winAudio);
      } else {
        change = 0; resultMsg = 'üôÅ –£–≤—ã ‚Äî –ø–æ–ø—Ä–æ–±—É–π –µ—â—ë';
        playSafe(loseAudio);
      }

      // soft background flash on win
      if (change > 0) flashBackground();

      // highlight winners (pulse)
      highlightWinners(names);

      // update balance
      balance += change;
      balEl.textContent = balance;
      messageEl.textContent = resultMsg;

      // send result to bot
      if (window.Telegram && Telegram.WebApp){
        Telegram.WebApp.sendData(JSON.stringify({ action:'slot_result', result: names.join(','), change: change }));
      }

      isSpinning = false;
      spinBtn.disabled = false;
    }

    // spinSingleReel: spins reel r for PER_REEL ms, then lands on targetFile, resolves when done
    async function spinSingleReel(r, targetFile, done){
      const reel = reels[r];
      reel.spinning = true;
      reel.speed = 1.8; // base speed multiplier (tunable)
      const startTime = performance.now();
      const duration = PER_REEL;
      const endTime = startTime + duration;

      // For motion blur effect: scale blur by speed
      const spriteStep = (reel.sprites[1].y - reel.sprites[0].y);

      // while spinning, repeatedly rotate the sprites vertically by moving y and wrapping
      let lastTick = performance.now();
      let accumulated = 0;
      while (performance.now() < endTime){
        const now = performance.now();
        const dt = now - lastTick;
        lastTick = now;
        // Move sprites: speed px per ms scaled by speed param
        const movePx = reel.speed * (spriteStep / 6) * (dt/16); // tuned for pleasant look
        for (let s of reel.sprites){ s.y -= movePx; }
        // wrap-around: if sprite y < top threshold, move to bottom with new texture
        const threshold = -spriteStep * CENTER_INDEX - spriteStep * 0.6;
        for (let i=0;i<reel.sprites.length;i++){
          const s = reel.sprites[i];
          if (s.y < threshold){
            // move to end
            s.y += spriteStep * reel.sprites.length;
            // assign a new random texture
            const tex = PIXI.Texture.from(SYMBOL_FILES[Math.floor(Math.random()*SYMBOL_FILES.length)]);
            s.texture = tex;
          }
        }
        // visual update (scale/alpha/blur)
        updateDepthVisuals();

        // spawn particles proportional to reel.speed
        const intensity = Math.min(1, reel.speed);
        emitParticlesFromReel(r, intensity * 0.6);

        await new Promise(res => setTimeout(res, TICK_MS));
      }

      // approaching stop: we want to land the CENTER_INDEX sprite on targetFile.
      // find nearest sprite to center and rotate so center shows target
      // We'll perform a smooth animation to align center with target texture, with small deceleration and final bounce.

      // Step1: pick some frames to animate - a smooth decelerating scroll
      const finalIndex = reel.sprites.findIndex(s => {
        // prefer any sprite, we'll overwrite textures during aligning
        return true;
      });

      // compute current center offset
      // We'll do N steps of swapping while shifting y so that the center sprite becomes targetFile
      const steps = 8 + Math.floor(Math.random()*6); // number of minor steps to simulate slowing
      for (let step=0; step<steps; step++){
        // each step: shift by spriteStep roughly / steps, and change texture on the leaving sprite
        const now = performance.now();
        // dynamic easing on step duration (increasing)
        const stepDuration = 70 + step*25; // grows
        const frameCount = Math.max(1, Math.round(stepDuration / 16));
        for (let f=0; f<frameCount; f++){
          const frac = (f+1)/frameCount;
          const dy = (spriteStep / steps) * frac;
          for (let s of reel.sprites) s.y -= dy;
          // wrap check
          for (let i=0;i<reel.sprites.length;i++){
            const s = reel.sprites[i];
            if (s.y < threshold){
              s.y += spriteStep * reel.sprites.length;
              const tex = PIXI.Texture.from(SYMBOL_FILES[Math.floor(Math.random()*SYMBOL_FILES.length)]);
              s.texture = tex;
            }
          }
          updateDepthVisuals();
          emitParticlesFromReel(r, 0.35);
          await new Promise(res => setTimeout(res, 16));
        }
      }

      // finally set center sprite to targetFile
      // find the sprite closest to y=0 and set its texture to targetFile
      let minDist = Infinity, centerSprite = null;
      for (let s of reel.sprites){
        if (Math.abs(s.y) < minDist){ minDist = Math.abs(s.y); centerSprite = s; }
      }
      if (centerSprite){
        centerSprite.texture = PIXI.Texture.from(targetFile);
        // perfect align: shift all sprites so that centerSprite.y == 0 (smooth)
        const offset = centerSprite.y; // we need to subtract this from all
        const alignFrames = 12;
        for (let i=0;i<alignFrames;i++){
          const frac = (i+1)/alignFrames;
          for (let s of reel.sprites){ s.y -= offset * (frac/alignFrames); }
          updateDepthVisuals();
          emitParticlesFromReel(r, 0.6);
          await new Promise(res => setTimeout(res, 16));
        }
        // micro-bounce: overshoot then settle
        const bounceAmt = 8;
        for (let i=0;i<6;i++){
          const t = i/6;
          const dy = Math.sin(t*Math.PI) * (bounceAmt * (1-t));
          for (let s of reel.sprites) s.y -= dy;
          updateDepthVisuals();
          await new Promise(res => setTimeout(res, 16));
        }
      }

      // final small burst
      for (let i=0;i<8;i++) emitParticlesFromReel(r, 0.9*Math.random());

      reel.spinning = false;
      resolveDone();

      function resolveDone(){
        // tiny delay to keep reel showing
        setTimeout(()=> done(), 120);
      }
    } // end spinSingleReel

    // flash background on win
    function flashBackground(){
      const original = document.body.style.background;
      document.body.style.transition = 'background 600ms ease';
      document.body.style.background = 'linear-gradient(180deg,#0b2a4a,#06314a)';
      setTimeout(()=>{ document.body.style.background = original; }, 1000);
    }

    // highlight winners with pulse
    function highlightWinners(names){
      // if triple - pulse all, else pulse those part of pair
      if (names[0] === names[1] && names[1] === names[2]){
        for (let el of reels) {
          el.container.children.forEach(()=>{});
        }
        // simply pulse center sprite of all reels
        for (let r=0;r<REEL_COUNT;r++){
          const s = reels[r].sprites[CENTER_INDEX];
          s.parent.className = ''; // noop
          s.parent && s.parent;
          // visual effect: scale and tint
          gsPulse(s);
        }
      } else {
        // pair highlight
        for (let r=0;r<REEL_COUNT;r++){
          const s = reels[r].sprites[CENTER_INDEX];
          const fname = (s.texture.baseTexture.resource.url||'').split('/').pop();
          if (names.filter(n=>n.includes(fname.split('.')[0])).length > 1) gsPulse(s);
        }
      }

      function gsPulse(sprite){
        // quick scale/tint pulse using tween-like approach
        const startScale = sprite.scale.x;
        let t = 0;
        const dur = 900;
        const start = performance.now();
        function step(){
          const now = performance.now();
          t = (now-start)/dur;
          if (t >= 1){ sprite.scale.set(startScale); return; }
          const ease = Math.sin(t*Math.PI); // simple ease
          sprite.scale.set(startScale * (1 + 0.18*ease));
          requestAnimationFrame(step);
        }
        requestAnimationFrame(step);
      }
    }

    // updateParticles on ticker
    let lastNow = performance.now();
    app.ticker.add((delta)=>{
      const now = performance.now();
      const dt = now - lastNow;
      lastNow = now;
      updateParticles(now, dt);
    });

    // wire spin button
    spinBtn.addEventListener('click', ()=>{ if (!isSpinning) spinAll().catch(e=>{console.error(e); isSpinning=false; spinBtn.disabled=false;}); });

    // initial visuals update
    updateDepthVisuals();

    // expose helpful console commands for testing (optional)
    window._rc = reels;

    // ensure canvas resizes properly initially
    setTimeout(()=>{ app.renderer.resize(app.view.width, app.view.height); updateDepthVisuals(); }, 100);

  })();
  </script>
</body>
</html>
